'use strict'
// замыкание - используется не часто - 
// замыкание - ф-ция со всеми переменными, которые ей доступны.
// Переменные, которые ф-ция может ииспользоваться находятся в замыкании с этой функцией

/*const z = 5;

const closeOne = () => {
   const x = 10;

   const closeTwo = (y) => {
      const closeThree = () => {
         return x + y;
      };

      return x + y + closeThree();
   };  

      return closeTwo(12);
   
};

console.log(closeOne());
*/
/*
const double = (x) => {
   return () => {
      console.log(x * x);
   }
};

const pow = double(10);
const pow2 = () => {
   console.log(x * x);
};
pow();
console.dir(pow);
console.dir(pow2);
*/

// После обьявления переменной внутри ф-ции, доступ к ней возможен только внутри ф-ции. 
// Такие переменные называют определенными в контексте этой ф-ции или локальными.
// Если ф-ция обьявляется внутри другой ф-ции, то внутренняя ф-ция называется замыканием, т.к. эта ф-ция сохраняет доступ к внешней ф-ции.
// Ф-ция высшего порядка - ф-ция, в которой в качестве аргумента приходит ф-ция или в качестве результата может возвращаться ф-ция.
// Если ф-ция в качестве аргумента - то это коллбэк.
// Если ф-ция в качестве результата - то это фабрика ф-ции на замыкание.
// Обертка - когда в аргументах приходит ф-ция и возвращается ф-ция.

// пример 3 замыкания

/* const bar = (x) => {
   const y = 'II замыкание';
   return (z) => {
      console.log(x, y, z);
   }
};

const foo = bar('I Замыкание');

foo('III не замкнут');

console.dir(foo);
*/

// пример 4 замыкания

const bar = (x) => (y) => (z) => x + y + z;
const foo1 = bar(5);
console.log('foo1: ', foo1);
const foo2 = foo1(15);
console.log('foo2: ', foo2);
const foo3 = foo2(35);
console.log('foo3: ', foo3);

console.log(bar(5)(15)(35));





